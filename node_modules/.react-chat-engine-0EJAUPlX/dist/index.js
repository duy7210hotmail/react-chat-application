function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var _$1 = _interopDefault(require('lodash'));
var reactChatEngine = require('react-chat-engine');
var nextjsWebsocket = require('nextjs-websocket');
var axios = _interopDefault(require('axios'));
var icons = require('@ant-design/icons');
var reactSpring = require('react-spring');
var reactGridSystem = require('react-grid-system');
var reactScroll = require('react-scroll');

var ChatEngineContext = React.createContext();
var ChatEngineWrapper = function ChatEngineWrapper(props) {
  var _useState = React.useState(null),
      conn = _useState[0],
      setConn = _useState[1];

  var _useState2 = React.useState(null),
      creds = _useState2[0],
      setCreds = _useState2[1];

  var _useState3 = React.useState(''),
      sessionToken = _useState3[0],
      setSessionToken = _useState3[1];

  var _useState4 = React.useState(null),
      chats = _useState4[0],
      setChats = _useState4[1];

  var _useState5 = React.useState({}),
      messages = _useState5[0],
      setMessages = _useState5[1];

  var _useState6 = React.useState(null),
      activeChat = _useState6[0],
      setActiveChat = _useState6[1];

  var _useState7 = React.useState({}),
      typingCounter = _useState7[0],
      setTypingCounter = _useState7[1];

  var _useState8 = React.useState(false),
      loadMoreMessages = _useState8[0],
      setLoadMoreMessages = _useState8[1];

  var _useState9 = React.useState(false),
      isBottomVisible = _useState9[0],
      setIsBottomVisible = _useState9[1];

  var value = {
    conn: conn,
    setConn: setConn,
    creds: creds,
    setCreds: setCreds,
    sessionToken: sessionToken,
    setSessionToken: setSessionToken,
    chats: chats,
    setChats: setChats,
    messages: messages,
    setMessages: setMessages,
    activeChat: activeChat,
    setActiveChat: setActiveChat,
    typingCounter: typingCounter,
    setTypingCounter: setTypingCounter,
    loadMoreMessages: loadMoreMessages,
    setLoadMoreMessages: setLoadMoreMessages,
    isBottomVisible: isBottomVisible,
    setIsBottomVisible: setIsBottomVisible
  };
  return /*#__PURE__*/React__default.createElement(ChatEngineContext.Provider, {
    value: value
  }, props.children);
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;

  _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function getDateTime(date, offset) {
  if (!date) return '';
  date = date.replace(' ', 'T');
  offset = offset ? offset : 0;
  var year = date.substr(0, 4);
  var month = date.substr(5, 2);
  var day = date.substr(8, 2);
  var hour = date.substr(11, 2);
  var minute = date.substr(14, 2);
  var second = date.substr(17, 2);
  var d = new Date(year + "-" + month + "-" + day + "T" + hour + ":" + minute + ":" + second);
  d.setHours(d.getHours() + offset);
  return d;
}
var options = {
  weekday: 'short',
  month: 'short',
  day: 'numeric',
  year: 'numeric'
};
function formatTime(dateTime) {
  var time = dateTime.toLocaleString('en-US');
  return time.split(' ')[1].slice(0, -3) + ' ' + time.slice(-2);
}
function formatDate(dateTime) {
  return dateTime.toLocaleString('en-US', options);
}
function formatDateTime(dateTime) {
  return formatTime(dateTime) + ', ' + formatDate(dateTime);
}

var _this = undefined;
var socketRef = undefined;
var pingIntervalID = 0;
var timeIntervalID = 0;
var minLag = 15 * 1000;
var initialLoadTime = Date.now() + 10 * 1000;

var Socket = function Socket(props) {
  var handleEvent = function handleEvent(event) {
    try {
      var eventJSON = JSON.parse(event);
      console.log('eventJSON.action', eventJSON.action);

      if (eventJSON.action === 'pong') {
        setShouldPongBy(Date.now() + minLag);
      } else if (eventJSON.action === 'login_error') {
        var sessionKey = props.projectID + "/" + props.userName + "/" + props.userSecret;
        localStorage.removeItem(sessionKey);
        props.onFailAuth && props.onFailAuth(conn);
      } else if (eventJSON.action === 'new_chat') {
        var chat = eventJSON.data;

        if (chats) {
          var newChats = _extends({}, chats);

          newChats[chat.id] = chat;
          setChats(newChats);
          setActiveChat(chat.id);
        }

        props.onNewChat && props.onNewChat(eventJSON.data);
      } else if (eventJSON.action === 'edit_chat') {
        handleEditChat(eventJSON.data);
      } else if (eventJSON.action === 'delete_chat') {
        var _chat = eventJSON.data;

        if (chats) {
          chats[_chat.id] = undefined;
          setChats(chats);

          if (!_.isEmpty(chats)) {
            var sortedChats = sortChats(chats);
            setActiveChat(sortedChats[0] ? parseInt(sortedChats[0].id) : 0);
          }
        }

        props.onDeleteChat && props.onDeleteChat(_chat);
      } else if (eventJSON.action === 'add_person') {
        handleEditChat(eventJSON.data);
        props.onAddPerson && props.onAddPerson(eventJSON.data);
      } else if (eventJSON.action === 'remove_person') {
        handleEditChat(eventJSON.data);
        props.onRemovePerson && props.onRemovePerson(eventJSON.data);
      } else if (eventJSON.action === 'new_message') {
        var _eventJSON$data = eventJSON.data,
            id = _eventJSON$data.id,
            message = _eventJSON$data.message;

        if (parseInt(id) === parseInt(activeChat)) {
          var newMessages = _extends({}, messages);

          newMessages[message.created] = message;
          setMessages(newMessages);
        }

        if (message.sender_username !== props.userName && isBottomVisible) {
          reactChatEngine.readMessage(conn, activeChat, message.id, function (chat) {
            return handleEditChat(chat);
          });
        }

        props.onNewMessage && props.onNewMessage(id, message);
      } else if (eventJSON.action === 'edit_message') {
        var _eventJSON$data2 = eventJSON.data,
            _id = _eventJSON$data2.id,
            _message = _eventJSON$data2.message;

        if (